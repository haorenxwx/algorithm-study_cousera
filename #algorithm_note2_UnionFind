#algorithm_note2_UnionFind

## union fund
###dynamic connectivity
	problem:
	- union command:
	- find connected query of any 2 objects(if there is a path):
	
	modeling the objects:
	- pixels in a digital photo
	- computers in a network
	- transistors in a computer chip
	- ...
	
	modeling the connections
	- p is connected to q
	- connected components:
		{0}{1 4 5}{2 3 6 7}
		inside each set(component), objects are connected
	
	Implementing the operations
	- find query: check is 2 objects are in the same component
	- union command: replace components containing 2 objects with their union.

	Union-find data type(API)(design efficient data structure for union find)
	- Dynamic-connecttivity client
		. read in pair of integers form standard input
		. if not connected, connect them and print out pair
	'''
	public static void main(String[] args)
	{
		int N = StdIn.readInt():
		UF uf = new UF(N);
		while (!StdIn.isEmpty())
		{
			int p = StdIn.readInt();
			int q = StdIn.readInt();
			if (!uf.connected(p, q))
			{
				uf.union(p, q);
				StdOut.printIn(p + " " + q);
			}
		}
	}	#test whether the algorithm is working as expected
	'''

###quick find--using eager approach
	Data structure:
	- iterger array id[]
	- p and q are connected iff(if and only if) they have the same id.
		0 1 2 3 4 5 6 7 8 9 
	id[]0 1 1 8 8 0 0 1 8 8		---0,5,6 are connected

	Find
	check if p and q have the same id

	union
	to merge components containing p and q, change all the entries whose id equals id[p] to id[q]
		0 1 2 3 4 5 6 7 8 9 
	id[]0 1 1 8 8 0 0 1 8 8		---union 6 and 1
		0 1 2 3 4 5 6 7 8 9 
	id[]1 1 1 8 8 1 1 1 8 8		---change the id[6] to the id[1] 
	'''
	public class QuickFindUF
	{
		private int[] id;
		public QuickFindUF(int N)
		{
			id = new int[N];
			for (int i = 0; i < N; i ++)
				id[i] = i;
		}
		public boolean connected(int p, int q)
		{ return id[p] == id[q];}	
		/*check if p and q are in the same component*/
		public void union(int p, int q)
		{
			int pid = id[p];
			int qid = id[q];
			for (int i = 0; i < id.length; i++)
				if(id[i] == pid) id[i] = qid; 
		}
	}
	'''
	'''
	class QuickFindUF(object):
		def QuickFindUF(N):
			for i in range(0,N-1):
				id[i] = i
		def Connected(p, q):
			return id[p]==id[q]
		def Union(p, q):
			pid = id[p]
			qid = id[q]		
			# need to get the value of id[p] first, otherwise, it will change
			for i in range(len(id)):
				if id[i] == pid:
					id[i] = qid
	#implement in python
	'''
	**quick find is too slow**
	Cost model: number of array accesses(for read or write)
	It is a quadratic algorithm, do not scale(large calculation)

###Quick find


##step of developing a usable algorithm
	- model the problem
	- find an algrithm to solve
	- fast enough? fit in memory?
	- if not, figure out why
	- find a way to address the problem
	- iterate untill saticfied

